%!TEX root = paper.tex

\section{Libraries and abstractions}
\label{sec:libraries}

Many high-level languages provide abstractions over I/O, threading, parallelism, and concurrency.
This area is one where we started out with much larger aspirations in Rust but ultimately had to pare back,
for reasons very similar to the reasons that we have avoided GC by default --- it is difficult to provide a
predictable, fast implementation that works across all platforms of many systems features.
For example, thread-local storage (TLS) provides variables that are associated with a given thread.
In the presence of both lightweight (stackless) and full native threads across a variety of architectures, though,
it becomes difficult to understand what the cost of initialization and storage are for this feature.
Even lightweight threads in general, when interacting with a built-in scheduler and generic I/O system that
has to work across a variety of platforms (including Windows!) were too expensive to support in practice and
had to be removed.

Even some basic sharing, such as hash tables and vectors has proven challenging.
For example, most web browsers have implementations of vectors that allow instantiation with a default inline size,
as they have use cases where they create many thousands of vectors, nearly none of which have more than 4~elements.
In that case, removing the extra pointer indirection --- particularly if the values are of less than pointer size ---
can be a significant space savings.
But, these sorts of libraries are more highly optimized for a web browser than for a general-purpose systems language.

\subsection{Concurrency and parallelism}

Concurrency and data parallelism are two places where Rust's type system is very close to perfectly suited.
In concurrent and (safe) data parallel libraries, the data operated on by distinct threads is also itself distinct.
Through the use of Rust's ownership model, data cannot be owned by two threads at the same time.
In the case of concurrency this works quite well --- there are often individual objects that need to be owned by
a single object at a time.

%http://is.gd/tkcD9R
\begin{lstlisting}
fn main() {
  let mut data = Box::new(0);

  Thread::spawn(move || {
    *data = *data + 1;
  });
  Thread::spawn(move || {
    *data = *data + 1;
  });
  print!(``{}'', data);
}
\end{lstlisting}


Data parallelism is a bit more tricky today because there is no way to \eg{} partition a vector in safe code
for a data parallel operation and then stitch it back together afterwards without performing a copy of the data.

TODO: code sample


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
