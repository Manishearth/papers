===========================================================================
ICFP '15 Review #31A
---------------------------------------------------------------------------
Paper #31: Experience Report: Developing the Servo Web Browser Engine using
Rust
---------------------------------------------------------------------------


Overall merit: 3. Weak accept
Reviewer expertise: 4. Expert

===== Paper summary =====

This experience report presents Servo a new web browser implemented
in the Rust programming language. The paper discusses the pros and
cons of Rust for this implementation.

===== Evaluation =====

pros     : - Interesting project.
cons     : - The benefit of using Rust is not clearly established by the paper.
- The paper lakes a big lesson the reader should have learned.

===== Comments for author(s) =====

Section 4.1, seems related to the expression problem, which is surprisingly
not mentioned here.

Section 4.2, what does it means that Rust embeds serialized generic function
ASTs within "compiled" binary? What's the point? When and how these ASTs
are later used?

Section 5.1, JS JIT, I'm not sure to understand why you consider than JIT
correctness is a problem faced by Rust, inside the Servo implementation.
A little bit of elaboration would have helped me to understand the
problem you want to address here.

Same remark for the "incremental computation". Why does it relate to Rust?

===========================================================================
ICFP '15 Review #31B
---------------------------------------------------------------------------
Paper #31: Experience Report: Developing the Servo Web Browser Engine using
Rust
---------------------------------------------------------------------------


Overall merit: 3. Weak accept
Reviewer expertise: 3. Knowledgeable

===== Paper summary =====

This paper describes the ongoing project of implementing the web rendering engine Servo in Rust. It briefly sketches the rendering pipeline, briefly flashes by a couple of Rust features, and then describes how the Servo project benefits from various other features of Rust.

===== Evaluation =====

It is good to see a paper like this. It provides useful background on Rust, its goals, and how some of its design was informed by the needs of the Servo project. It describes some of the successes of these design choices.

Yet, I had hoped for more: an analysis of the difficulties of programming against Rust’s type discipline; an estimate of the corresponding engineering costs (Rusts safety guarantees are awesome, but can you put a price tag on them?); ideally, concrete examples of what the type system makes easy and what is hard; concrete numbers about how much code in Servo is unsafe, perhaps with some breakdown why; how much the different memory management abstractions from the Rust library are used, and how well they work and interact in practice; and finally, what were the main design failures, where did you have to backtrack?

Also, the intro sections on “Browers” and “Rust” didn’t work that well. The former, because most of it is too generic to contribute much to the rest of the paper. The latter because it only scratches the surface, dumps some source code snippets on the reader, but doesn’t explain the idiosyncracies sufficiently to make them understandable to non-Rusties.

I suggest to condense Sec 2, expand slightly on the examples in Sec 3, and use the additional free space to address some of the questions above.

===========================================================================
ICFP '15 Review #31C
---------------------------------------------------------------------------
Paper #31: Experience Report: Developing the Servo Web Browser Engine using
Rust
---------------------------------------------------------------------------


Overall merit: 4. Accept
Reviewer expertise: 3. Knowledgeable

===== Paper summary =====

This paper reports on the development of the Servo web-browser engine
in Rust.  The paper reports significantly better performance numbers
for Servo's rendering engine as compared to that of Mozilla's Gecko.
It discusses the impact of some of Rust's design and implementation
choices on the development of a performant web-browser engine.

The paper also describes several open problems, for instance,
reasoning about the correctness of unsafe code blocks (which are
frequent in the implementation of Rust libraries) and just-in-time
code generated by JavaScript engines.

===== Evaluation =====

The paper provides a useful experience report on the use of a
memory-safe and data-race free language when implementing a
web-browser engine.  The paper is structured well for an experience
report: it first explains the basics of the domain (i.e., what are the
steps taken in a browser to process a site) and then discusses the
basics of Rust, as well as Rust's support for language
interoperability, concurrency, and macros.

I think this will make for an interesting and well received talk at
ICFP.

The one weakness of the paper is the writing, which I think can be
improved significantly.  In particular, there are a lot of long,
run-on sentences.  Also, the paper assumes throughout that the reader
is completely familiar with Rust syntax.  (See comments below.)

===== Comments for author(s) =====

- Abstract: Run-on sentence in last line of second paragraph.  The
sentence should end at "community".  Get rid of the the final part
of the sentence ("forming a novelty --- a useful ... language.")

- pg 1, sentence that spans bottom of column 1 to top of column 2:
split the sentence into two.

- pg 2, section 2.5: "Layerization is used" -- maybe explain what
layerization is.

- pg 3, Section 3.1: explain the Rust syntax, APIs (e.g., Box, scoped,
and || ).

- pg 3, Section 4: when you mention Table 1, say something in the text
that points out the better performance instead of just leaving it to
the reader to figure it out.

- pg 3, section 4.1: "fu[n]ction tables"

- pg 4: Explain "embedding serialized generic function ASTs within
'compiled' binaries"

- pg 4, section 4.3: "We have implemented wrapper types and compiler
plugins that restrict incorrect use of foreign function values".
Give an example to clearly explain what you mean and how these
wrappers restrict incorrect use.

- pg 5, Figure 5: Explain Rust's macro syntax and walk the reader
through the code in Fig 5.

