%!TEX root = paper.tex

\section{Introduction}
\label{sec:intro}
At the heart of a modern web browser is the browser engine, which is the code responsible
for loading, processing, evaluating, and rendering web content.
There are three current browser engine families:
\begin{enumerate}
\item Trident/Spartan, the engine in Internet Explorer~\cite{IE}
\item Webkit\cite{WEBKIT}/Blink, the engine in Safari~\cite{SAFARI}, Chrome~\cite{CHROME}, and Opera~\cite{OPERA}
\item Gecko, the engine in Firefox~\cite{FIREFOX}
\end{enumerate}
All of these engines have at their core many millions of lines of \Cplusplus code.
While the use of \Cplusplus has enabled all of these browsers to achieve excellent sequential
performance on a single web page, on mobile devices with lower processor speed but many
more processors, these browsers do not provide the same level of interactivity that they
do on desktop processors~\cite{parallelizing-web-pages,ZOOMM}.
Further, in an informal inspection of the critical security bugs in Gecko, we determined that
roughly 50\% of the bugs are use after free, out of range access, or related to integer
overflow.
The other 50\% is split between errors in tracing values from the JavaScript heap in the
\Cplusplus code and errors related to dynamically compiled code.

Servo\footnote{https://github.com/servo/servo} is a new web browser engine whose development
was started in February of 2013.
The goal of this project is to produce a browser that enables new applications to be authored
against the web platform that run with more safety, better performance, and better power usage
than in current browsers.
Modern web browser engines have a similar complexity level to that of operating systems.
These engines are expected to execute arbitrary user programs within a safe sandbox, scale 
across a wide variety of hardware, manage access to shared system resources, and further 
do all of that while providing good performance and correct behavior
against sometimes-incomplete standards.
With the expectation of executing well on mobile devices and parallel hardware, the 
fundamental design assumptions have significantly changed since all of the modern
web engines were originally designed.


In this paper, \emph{systems} \emph{software} refers to programs that have some combination
of soft realtime requirements and memory, CPU, and power usage constraints that require the
programmer to be able to predict these features from their source code --- without being a
compiler developer.

enabled us to take on this project in a type-centric way instead of
the traditional C++ that relies on coding conventions, imprecise static analyses, and
fuzzers.
While many languages before have offered some combination of memory safety, parallelism,
and concurrency, Rust is, to our knowledge, the first to do so that provides the programmer
with the control over both memory and generated code that is required by systems programmers.
Servo is currently over 300k lines of code and implements enough of the web to render and
process many pages, though it is still a far cry from the over 7 million lines of code in
the Mozilla Firefox browser and its associated libraries.
However, we believe that we have implemented enough of the web platform to provide an
early report on the successes, failures, and open problems remaining in Servo, from the
point of view of programming languages and runtime research.


Servo is a new web browser engine designed to address the major environment and 
architectural changes over the last decade.
To address security, we are using a new systems programming language, Rust,
which adds static type checking to address by far the top cause of security
issues in modern web browsers --- failure in handling manual memory allocation
in \Cplusplus{}.
We scale across a wide variety of hardware by building either data- or task-parallelism, 
as appropriate, to each of the stages of the Web layout pipeline.
Finally, we are improving concurrency by reducing the simultaneous access to data
structures and using a message-passing architecture between components such as the
JavaScript engine and the rendering engine that is painting graphics to the screen.
In this experience report, we discuss the design and architecture of a modern web 
browser engine, show how modern programming language techniques --- many of which
originated in the functional programming community --- address these design 
constraints, and also touch on ongoing challenges and areas of research where we
would welcome additional community input.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
